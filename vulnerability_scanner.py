# -*- coding: utf-8 -*-

#Imports
import bcolors
import os
import urllib.request
#import getproxy
import time
import socket

#Constants
headers = { 'User-Agent' : 'Mozilla/5.0' }

# Tests for normal error-based sql injection vulnerability
def sql_error_scan(url,v = False) :
    errorStrings = ["SQL Syntax", "SQL SYNTAX", "SQL Error", "SQL Error", "SQL ERROR", "sql_"]
    req = urllib.request.Request(url + "'", None, headers)

    try :
        src = urllib.request.urlopen(req).read()
    except:
        return False

    for err in errorStrings :
        if err in str(src) :
            if (v) :
                bcolors.printGreen("[+]Found '" + err + "' reference in url: " + url)
            return True

# Tests for blind time-based sql injection vulnerability
def sql_time_scan(url, v = False) :
    sleepCommands = ["-SLEEP(5000)", 
                     "-BENCHMARK(1000000000000000, rand())",
                     "; WAIT FOR DELAY '00:10:00'",
                     "'BEGIN DBMS_LOCK.SLEEP(15); END;--" ]
    
    #Get normal load-time
    req = urllib.request.Request(url, None, headers)
    timeStart = time.time()
    try :
        response = urllib.request.urlopen(req)
    except :
        return False

    latency = time.time() - timeStart
    if (v):
        print("[*]Latency is " + str(latency))
    socket.setdefaulttimeout(3*latency)

    for test in sleepCommands :
        req = urllib.request.Request(url + test, None, headers)
        try :
            response = urllib.urlopen(req)
        except socket.timeout :
            if (v) :
                bcolors.printGreen("[+] Time-based sql vulnerability found in url: ")
            return True
        except:
            continue
    return False

# The function which handles the reflected XSS vulnerability test,
# which looks for our script injection in the produced source
def xss_vuln_scan(url, v = False) :
    #source: http://breakthesecurity.cysecurity.org/2012/02/complete-cross-site-scriptingxss-cheat-sheets-part-1.html
    xssStrings = ['>"><script>alert("1VULN")</script>&',
                  '<script>alert(“1VULN”)</script>',
                  '<script>alert(‘1VULN’)</script>',
                  '“><script>alert(“1VULN”)</script>',
                  '<script>alert(/1VULN”)</script>',
                  '<script>alert(/1VULN/)</script>',
                  '<ScRiPt>alert("1VULN")</sCriPt>',
                  '<IMG SRC=jAVasCrIPt:alert(‘1VULN’)>',
                  '<IMG SRC=”javascript:alert(‘1VULN’);”>',
                  '<IMG SRC=javascript:alert(&quot;1VULN&quot;)>',
                  '<IMG SRC=javascript:alert(‘1VULN’)',
                  '<<SCRIPT>alert(“1VULN”);//<</SCRIPT>']

    for test in xssStrings :
        req = urllib.request.Request(url + test, None, headers)
        try :
            response = urllib.request.urlopen(req)
        except socket.timeout:
            return False # Don't keep going if site is down
        except :
            continue
        src = response.read()

        if ('<script>alert("1VULN")' in str(src) or '<IMG SRC=javascript:alert' in str(src)) :
            if (v) :
                bcolors.printGreen("[+]Found XSS vulnerability!")
            return True
    return False

# The main function which runs all the tests according to the level specified
def run_tests(links, testLevel = 1, v = False) :
    vulnUrls = []
    if (links == [] or links == None) :
        bcolors.printFail("[-]Invalid input parameters! Exiting...")
        return
    for link in links :
        sqlI = True # Used to check if we need to perform a second sqlInjection test
        if (testLevel > 0) :
        #Basic SQLi
            if(sql_error_scan(link, v)) :
                vulnUrls.append((link, "SQLi"))
                sqlI = False
        if (testLevel > 1 and sqlI ) :
        #Time based SQLi
            if(sql_time_scan(link, v)) :
                vulnUrls.append((link, "SQLiT"))
        if (testLevel > 2) :
        #XSS
            if(xss_vuln_scan(link, v)) :
                vulnUrls.append((link, "XSS"))
    
    return vulnUrls
    
if __name__ == '__main__' :
    testURLS = ['http://php.net/manual/en/domnodelist.item.php']
    #import sys
    #reload(sys)
    #sys.setdefaultencoding('utf-8')
    res = run_tests(testURLS, 3, True)
    print(str(res))
