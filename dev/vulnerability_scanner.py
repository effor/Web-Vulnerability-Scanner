# -*- coding: utf-8 -*-

#Imports
import bcolors
import os
import urllib.request
import get_proxy
import time
import socket
import TestObject
import data

# Tests for normal error-based sql injection vulnerability.
# These tests are performed by inserting a sql syntax character,
# and then searching for the error response. 
# The function returns the character which caused the error!
def sql_error_scan(url,v = False) :
    req = urllib.request.Request(url + "'", None, data.headers)

    try :
        src = urllib.request.urlopen(req).read()
    except:
        return None

    for err in data.errorStrings :
        if err in str(src) :
            if (v) :
                bcolors.printGreen("[+]Found '" + err + "' reference in url: " + url)
            return "'"

# Tests for blind time-based sql injection vulnerability.
# It measures the default latency, then injects a sleep command,
# sets the timeout to 3 times the default latency, and then
# catches the eventual timeout exception.
def sql_time_scan(url, v = False) :
    #Get normal load-time
    req = urllib.request.Request(url, None, data.headers)
    timeStart = time.time()
    try :
        response = urllib.request.urlopen(req)
    except :
        return None

    latency = time.time() - timeStart
    if (v):
        print("[*]Latency is " + str(latency))
    socket.setdefaulttimeout(3*latency)

    for test in data.sleepCommands :
        req = urllib.request.Request(url + test, None, data.headers)
        try :
            response = urllib.urlopen(req)
        except socket.timeout :
            if (v) :
                bcolors.printGreen("[+] Time-based sql vulnerability found in url: ")
            return test
        except:
            continue
    return None

# The function which handles the reflected XSS vulnerability test,
# which injects a string and then looks for that string in the
# source code of the html page.
def xss_vuln_scan(url, v = False) :
    for test in data.xssStrings :
        req = urllib.request.Request(url + test, None, data.headers)
        try :
            response = urllib.request.urlopen(req)
            src = response.read()
        except socket.timeout:
            return None # Don't keep going if site is down
        except :
            continue

        if ('<script>alert("1VULN")' in str(src) or '<IMG SRC=javascript:alert' in str(src) or "<1VULN>" in str(src)) :
            if (v) :
                bcolors.printGreen("[+]Found XSS vulnerability!")
            return test
    return None

# The main function which runs all the tests according to the level specified.
# The function first checks for an end case, and then moves on to the different tests.
# If verbose, it prints all the results.
def run_tests(links, testLevel = 1, v = False) :
    TestObjects = []
    if (links == [] or links == None) :
        bcolors.printFail("[-]Invalid input parameters! Exiting...")
        return
    for link in links :
        sqlI = True # Used to check if we need to perform a second time-based sqlInjection test
        res = sql_error_scan(link, v)
        if(res != None) :
            TestObjects.append(TestObject.TestObject(link, "SQLi", res))
            sqlI = False
        #Time based SQLi    
        if (testLevel > 1 and sqlI ) :
            res = sql_time_scan(link, v)
            if(res != None) :
                TestObjects.append(TestObject.TestObject(link, "SQLiT", res))
        #XSS
        if (testLevel > 2) :
            res = xss_vuln_scan(link, v)
            if(res != None) :
                TestObjects.append(TestObject.TestObject(link, "XSS", res))
    if (v) :
        if (TestObjects != []) :
            bcolors.printGreen("~*~*~*~*~PRINTING FOUND TARGETS~*~*~*~*~")
            for t in TestObjects :
                t.print_test()
        else :
            bcolors.printFail("~*~*~*~*~NO TARGETS FOUND~*~*~*~*~")
    return TestObjects
    
if __name__ == '__main__' :
    testURLS = ['http://php.net/manual/en/domnodelist.item.php']
    res = run_tests(testURLS, 3, True)
    #print(str(res))
